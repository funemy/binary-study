import subprocess
import re
import os
import os.path
import time
import dumphelper

OFFSETS_H_PATH = os.path.join("src","offsets.h")
TEMP_GDB_PATH = os.path.join("build", "temp.gdb")
BIN_PATH = os.path.join("bin", "YAN01_00015")
GITC_SRC_PATH = os.path.join("src", "gitc.c")

MEMSIZE_MAGIC = "0xcafebaba"
TEXT_HASH_MAGIC = "0xcafebabe"
DATA_HASH_MAGIC = "0xcafedada"

MAKE_BUILD_CMD = ["make", "-W", GITC_SRC_PATH, "build-orig"]
OBJDUMP_CMD = ["/usr/i386-linux-cgc/bin/objdump", "-d", BIN_PATH]
GDB_CMD = ["gdb", "-x", TEMP_GDB_PATH, BIN_PATH]

def INFO(msg) :
  print "INFO: " + msg

def removeOffsetsH() :
  os.remove(OFFSETS_H_PATH)

def eexit(ret) :
  #removeOffsetsH()
  exit(ret)

def findInsnAddr(magic) :
  sp = subprocess.Popen(OBJDUMP_CMD, stdout=subprocess.PIPE)
  sout, serr = sp.communicate()
  if not sout :
    return None,None

  bFound = False
  curLine = ""
  for l in sout.split('\n') :
    if l.find(magic) != -1:
      if bFound :
        INFO("More than one magic [%s] found in [%s] and [%s]" % (magic, curLine, l))
        return None,None

      bFound = True
      curLine = l

  #if we are here, process the l
  #804810b:	81 7d f4 ba ba fe ca 	cmpl   $0xcafebaba,-0xc(%ebp)
  i = curLine.find(':')
  addr = 0
  try :
    addr = int(curLine[:i], 16)
  except ValueError :
    INFO("Invalid address found in [%s]" % curLine)
    return None,None

  #we also need to find the memory location of the runtime value
  entries = curLine.split(',')
  if len(entries) == 0 :
    INFO("Couldn't find the memory location in [%s]" % (curLine))
    return None,None

  m = entries[-1]
  #assume that it will be in offset + register format
  i = m.find('(')
  j = m.find(')')

  if i == -1 or j == -1 or j < i :
    INFO("Couldn't find the memory location in [%s]" % (curLine))
    return None,None

  off = m[:i]
  reg = m[i+1:j]

  if reg not in ["%ebp", "%esp"] : #other ones possible?
    INFO("Couldn't find the memory location in [%s]" % (curLine))
    return None,None 

  return addr, reg.replace('%','$')+off

def findRuntimeValue(addr, valLoc) :
  rval = None

  #write the temporary gdb file
  fout = open(TEMP_GDB_PATH,"w")
  fout.write("break *0x%08x\n" % addr)
  fout.write("r\n")
  fout.write("x /x %s\n" % valLoc)
  fout.write("quit\n")
  fout.close()

  sp = subprocess.Popen(GDB_CMD, stdout=subprocess.PIPE)
  sout, serr = sp.communicate()
  if not sout :
    return None,None

  bBreakpointFound = False
  for l in sout.split('\n') :
    if bBreakpointFound :
      i = l.find(':')
      if i != -1: #should only be 1 ':' which is right after breakpoint
        try :
          rval = int(l[i+1:], 16)
          return rval
        except ValueError :
          pass  
    else :
      if l.find("Breakpoint 1, 0x%08x" % addr) != -1 :
        bBreakpointFound = True 
 
  return None 
  
 
#first check to see if the offsets file exists, if it does then exit
if os.path.exists(OFFSETS_H_PATH) :
  bIsOffsetsValid = True
  #if it exists, make sure we are done with the work already
  for l in open(OFFSETS_H_PATH) :
    if l.find(MEMSIZE_MAGIC) != -1 or l.find(TEXT_HASH_MAGIC) != -1 or l.find(DATA_HASH_MAGIC) != -1 :
      #we found it so continue to the rest of the script
      INFO("offsets.h found, but MAGIC still exists in [" + l.strip() + "]" )
      bIsOffsetsValid = False
      break;

  if bIsOffsetsValid : 
    INFO("offsets file exists")
    exit(0)
  
#if it doesn't exist, then we need to create it. We do this in stages

#First, we generate a new offsets file

def writeOffsets(mem_h, text_h, data_h, byteDiffs) :
  offsets = open(OFFSETS_H_PATH, "w")

  offsets.write("//Autogenerated using calculateOffsets.py\n")
  offsets.write("#define EXPECTED_MEMSIZE " + mem_h + "\n")
  offsets.write("#define EXPECTED_TEXT_HASH " + text_h + "\n")
  offsets.write("#define EXPECTED_DATA_HASH " + data_h + "\n")

  offsets.write("#define NUM_SKIPS %u\n" % (len(byteDiffs)))
  offsets.write("TextProtectSkip skips[NUM_SKIPS] = { ")
  for bd in byteDiffs :
    offsets.write("{0x%s,%u}, " % (bd, byteDiffs[bd]))
        
  offsets.write(" };\n") 
  offsets.close()


def getMagicVal(curM, curT, curD, curS, magic) :
  #write the offsets as we know it now
  writeOffsets(curM, curT, curD, curS)

  #now that we have the offsets, lets try to figure out magic
  #we do this by calling make build-orig
  ret = subprocess.call(MAKE_BUILD_CMD)
  if ret != 0 :
    INFO("Make failed")
    eexit(ret)

  addr,valLoc = findInsnAddr(magic)
  if addr is None :
    eexit(5)

  #INFO("MEMSIZE ADDR IS 0x%08x, LOC = %s" % (addr, valLoc))

  #now that we have the memsize, lets create a gdb file to get the runtime value
  runtimeVal = findRuntimeValue(addr, valLoc)
  if runtimeVal is None :
    eexit(6)

  return addr, runtimeVal

curMemsize = MEMSIZE_MAGIC
curTextHash = TEXT_HASH_MAGIC
curDataHash = DATA_HASH_MAGIC
curSkips = {}


writeOffsets(curMemsize, curTextHash, curDataHash, curSkips)
ret = subprocess.call(MAKE_BUILD_CMD)
if ret != 0 :
  INFO("Make failed")
  eexit(ret)

#get the bytes that are diffent between regular and patched
curSkips = dumphelper.loadObjdumpOffsets()
#then get the address of the text_hash instruction since we will need to skip that too
addr,val = findInsnAddr(TEXT_HASH_MAGIC)
curSkips["%x" % addr] = 8

#addr,val = getMagicVal(curMemsize, curTextHash, curDataHash, curSkips, MEMSIZE_MAGIC)
#curMemsize = "0x%08x" % val
#time.sleep(1)
addr,val = getMagicVal(curMemsize, curTextHash, curDataHash, curSkips, DATA_HASH_MAGIC)
curDataHash = "0x%08x" % val
time.sleep(1)
addr,val = getMagicVal(curMemsize, curTextHash, curDataHash, curSkips, TEXT_HASH_MAGIC)
curTextHash = "0x%08x" % val
time.sleep(1)



writeOffsets(curMemsize, curTextHash, curDataHash, curSkips)
ret = subprocess.call(MAKE_BUILD_CMD)
exit(ret)

